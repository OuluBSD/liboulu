
namespace SomeNs:
	
	// forward declaration
	int TmplUser()
	
	obj SomeCls:
		int i;
		
		Ctor():
			i = TmplUser()
	
	void SomeFn():
		SomeCls some_cls_inst
		
	int SomeParamFn(int int_var):
		return int_var * 2
		
	template{obj T} obj SomeTmpl:
		T o
		
		Ctor():
			o = 0
			
		void Inc(): o = o + 1
		const T& Get() const: return o
		
	int TmplUser():
		SomeTmpl{int} o
		o.Inc()
		return o.Get()
		
		

namespace SomeMetaNs:
	
	metaobj SomeMetaObj:
		int abc
		
		Ctor():
			abc = 0
			
		stmtlist Init():
			int local_var
			
		stmtlist Process():
			local_var = 4
		
	
	meta stmtlst StaticMetaFn():
		pass
	
	
	void MetaUser():
		
		meta SomeMetaObj o
		
		@o.Init()
		@o.Process()
		


namespace SomePlanNs:
	
	
	planobj MultiLevelObj:
		attr: existing_solves_some_existential_problem, +but_it_creates_new
		
		
	metaobj MultiLevelObj:
		attr: -existing_solves_some_macro_problem_in_some_local_scope
		
	obj     MultiLevelObj:
		attr: -existing_solves_some_problem_in_function
		
	
	
	// All versions require SomeNs etc. (namespaces export v1.0 by default)
	dep: SomeNs >= 1.0, SomeMetaNs
	
	lib Common:
		desc: "This is some common software library"
		pass
	
	pkg SomeApp:
		desc: "This app does something"
		dep: Common
	
	// All major releases require SomeApp package
	ver>=1.0:
		dep: SomeApp
	
	


namespace SomeActionNs:
	
	planobj IntModifier:
		
